mutex_lock:
    (XCHG)TSL REGISTER,MUTEX | копирование мьютекса в регистр и установка
                             | его в 1
    CMP REGISTER,#0    | был ли мьютекс нулевым?
    JZE ok             | если он был нулевым, значит, не был
                       | заблокирован,поэтому нужно вернуть
                       | управление вызывающей программе
    CALL thread_yield  | мьютекс занят; пусть планировщик
                       | возобновит работу другого потока
    JMP mutex lock     | повторная попытка
    ok: RET            | возврат управления вызывающей программе;
                       | будет осуществлен вход в критическую область;


mutex_unlock:
MOVE MUTEX, #0          | сохранение в мьютексе значения 0
RET                    | возврат управления вызывающей программе   


// cmp [wqe], 0
// mov [wqe], 1

// xchg reg, [cell]
//За счет чего атомарность?
Отправляется сообщение на шину сообщение, что выполняется операция, а потом отправляется сообщение, что все завершено
Откуда берется сотни тактов на опевещание всех, что сейчас операция выполняется?
Это доступ к памяти + остановка операций с памятью другими процессорами + любой конфликт с другими процессорами
пытаясь заблокировать автобус
Нам нужно заблокировать шину, но на самом деле блокирутся кеш-строка используемой памяти, чтобы обеспечить 
возможность доступа к другой области памяти для других потоков.
Поэтому стоимость оповещания, что выполняется операция - это: доступ к кеш-памяти + возможная конкуренция с другим 
процессором на этой строке кеш-памяти + обновить в остальных потоках эти кеши
MESI