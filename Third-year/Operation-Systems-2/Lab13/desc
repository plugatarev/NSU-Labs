мутекс обеспечивает атомарность доступа к CV

Точное описание действия функции pthread_cond_wait(3C) звучит так.  Эта функция имеет два параметра, 
pthread_cond_t * cond и pthread_mutex_t *mx. При вызове wait мутекс должтся, он блокируется до того момента, 
пока мутекс не освободят.ен быть захвачен, в противном случае результат не определен. Wait освобождает мутекс 
и блокирует нить до момента вызова другой нитью pthread_cond_signal. После пробуждения wait пытается захватить 
мутекс если это не получае

Мутекс используется для защиты данных, используемых при вычислении условия, с которым связана наша условная 
переменная.

Проверка условия перед вызовом позволяет защититься от так называемой «ошибки потерянного пробуждения» 
(lost wakeup), т.е. от ситуации, когда производитель вызвал signal в то время, когда потребитель еще не был 
заблокирован в wait.

Необходимость в проверке условия после выхода из wait не столь очевидна. Действительно, решение задачи 
производитель-потребитель с одним производителем и одним потребителем будет работать и без этого.  
Но если производителей или потребителей будет несколько, между ними будет возникать конкуренция, и как раз для 
разрешения этой конкуренции необходимы мутекс и повторная проверка условия.

wait
The value specified by cond, mutex, or abstime is invalid. 
The mutex was not owned by the current thread at the time of the call.

signal
The value cond does not refer to an initialized condition variable.

pthread_cond_signal должен быть обернут в мутекс, в ином случае переменная состояния может измениться между 
тестированием соответствующего состояния и блокировкой в вызове pthread_cond_wait(), что может вызвать бесконечное ожидание.

pthread_cond_wait содержит в себе разрыв критичесокй области, т.к на нужно, чтобы кто-то мог делать pthread_cond_signal