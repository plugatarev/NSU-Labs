22 pipe - создает межпроцессный канал. 
Системный вызов pipe заполняет массив целых чисел file_descriptor двумя дескрипторами файлов. 
Оба дескриптора открыты для чтения и записи. Чтение из file_descriptor[0] обеспечивает доступ к данным, записанным
в file_descriptor[1], в порядке поступления(FIFO - first in, first out), а чтение из file_descriptor[1]
обеспечивает доступ к данным, записанным в file_descriptor[0], также в порядке FIFO.

Родительский процесс создает два подпроцесса, каждый из которых закроет ненужный ему конец программного канала.
Родитель закрывает оба конца канала, т.к не взаимодействует с порожденными  подпроцессами.
Неиспользуемые файловые дескрипторы необходимо закрывать потому, что программный
канал выдаёт условие конца файла только когда его пишущий конец закрыт. Если забыть закрыть один из дескрипторов,
процесс, ожидающий конец файла в канале, никогда его не дождётся. 
При fork происходит копирование файловых дескрипторов, а программный канал считается закрытым только когда будут
закрыты все копии связанного с этим каналом дескриптора.

27 Создается подпроцесс родителя
Системный вызов fork создаёт дочерний процесс исполняющего процесса.
Возвращаемое значение - это ноль в дочернем элементе и номер идентификатора процесса дочернего элемента в
родителе или -1 в случае ошибки.
Дочерний процесс наследует у родителя сегменты кода, данных и стека программы, файловые дескрипторы,
реальный и эффективный номер пользователя и номер группы. Дочерний процесс не наследует: идентификатор процесса,
идентификатор родительского процесса.

33-38 У подпроцесса закрывается один конец канала
39 В другой конец первый подпроцесс пишет в канал текстовое сообщение
Функция write() должна попытаться записать n байтов из буфера, в файл, связанный с дескриптором открытого файла.
Если количество байт, которые должны быть записаны, больше свободного пространства в канале, пишущий процесс
остановится, пока читающий процесс не освободит достаточно места для записи.

46 Создается второй подпроцесс родителя
51-62 Закрываются оба канала для родителя, т.к он не будет взаимодействовать с подпроцессами
63-68 Один конец канала для второго подпроцесса закрывается
72 С другого конца канала читается сообщение

Данные читаются из канала при помощи read. В отличие от обычных файлов, чтение разрушает
данные в канале. Это означает, что нет возможночти прочитать данные заново.
read читает столько данных, сколько на момент вызова есть в канале. Если количество байтов в канале меньше, 
чем требуется, read возвращает значение меньшее, чем его последний аргумент. read возвращает 0, если 
обнаруживает, что другой конец канала закрыт, т.е. все потенциальные пишущие процессы закрыли свои файловые
дескрипторы, связанные с входным концом канала. Также возвращает 0, показывая конец файла.Если буфер канала пуст,
но файловый дескриптор другого конца ещё открыт, read будет заблокирован.

77-81 Считанное сообщение преобразуется(все буквы переводятся в заглавные) и сообщение выводится в терминал при 
пощоци write(STDOUT_FILENO - дескриптор файла для стандартного вывода).
toupper - преобразует строчные буквы в прописные

Функция fgets() считывает байты из потока в массив, на который указывает s, до тех пор, пока не будет прочитано 
n−1 байт, или до символа новой строки, или пока до конца конца файла. 
В случае успеха функции gets() и fgets() возвращают строку.
Если возникает ошибка чтения, например, при попытке использовать эти функции для файла,
который не был открыт для чтения, возвращается нулевой указатель.
Функция strlen() возвращает количество байтов в s, не включая завершающий нулевой символ.
