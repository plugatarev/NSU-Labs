По коду:
1) Замечание по закрытию сокета(client.c): вынес close для сокета в main(81)
2) Не обрабатывал ситуацию, когда сервер замершался раньше клиента: сейчас ловлю SIGPIPE в клиенте.
   Ядро посылает сигнал SIGPIPE в результате записи в сокет, для которого принимающий процесс уже завершил работу(56)
3) Просили посмотреть по поводу ошибок memset. memset ошибок не возвращает

Вопросы: 
1) Объяснить, как работает connect
connect пытается установить соединение с сокетом, адрес которого передается вторым параметром.
Функция принимает следующие аргументы:
первый аргумент: Указывает файловый дескриптор сокета, через который мы хотим соединится с сервером 
второй аргумент: адрес указывающий на структуру содержащую адрес узла, к которому хотим присоединится.
адрес_len задает длину структуры sockaddr

Установка соединения определяется на основе сокета, дескриптор которого передается первым параметром:
Если тип STREAM - пытается установить соединение на основе протокола TCP(Используя тройное рукопожатие)
Если DGRAM - связывает сокет с адресом, но нет никакого рукопожатия.
В итоге все что будем отправлять/принимать, будет отправлятся/приниматься на указанный сокет, поэтому для общения 
можно использовать write/read.
Попытка соединения с сервером может потерпеть неудачу по нескольким причинам.
Если сокета не существует, если на нем не слушают
Машина, с которой устанавливается соединение, должна быть включена и связана с сетью(если сетевое взаимодействие).
Серверу должен быть присвоен адрес, с которым мы пытаемся соединиться, и в очереди запросов на соединение на стороне сервера должно 
быть достаточно места, чтобы поставить в очередь наш запрос.
Если соединение не может быть установлено немедленно и O_NONBLOCK не установлен для дескриптора файла для сокета, connect() будет 
блокироваться до неопределенного интервала времени ожидания, пока соединение не будет установлено.

Если соединение не может быть установлено немедленно и для дескриптора файла для сокета установлено значение O_NONBLOCK , 
функция connect() завершится ошибкой и установит для errno значение EINPROGRESS, но запрос на соединение не будет прерван, и 
соединение будет установлено асинхронно. Последующие вызовы connect() для того же сокета до того, как соединение будет 
установлено, завершатся ошибкой и присвоят errno значение EALREADY.

2) Объяснить, как работает bind
Сокеты, созданные с помощью функции сокета (3C) , изначально не имеют имени.
Системный вызов bind присваивает сокету адресс.
В нашем случае общение происходит на одном хосте, поэтому в качестве адреса используется имя файла, через который 
будет происходить обмен данными между процессами.
Первый параметр, является дескриптором файла сокета, созданный с помощью вызова socket, 
а второй – указателем на структуру адреса сокета. Третий параметр содержит размер указанной структуры адреса 
Создается файл в текущем каталоге с типом s(что значит сокет)
сокета. В случае успешного завершения вызова bind он возвращает значение 0. В случае ошибки, вызов bind возвращает -1.
Возвращает ошибку, если передали дескриптор ссылающийся не на сокет. Если указанный адрес уже используется. 
Если сокет уже привязан к адресу.

3) Объяснить, как работает listen
После вызова функции listen указанный сокет будет использоваться для приема запросов на соединение, регистрируется что сокет слушается
Функция listen() помечает сокет в режиме соединения, указанный первым аргументом, как принимающий соединения, и ограничивает 
количество незавершенных соединений в очереди прослушивания сокета до значения, указанного вторым аргументом.
Нужно в нашем случае, т.к используем TCP, нужно устанавливать соединение до начала общения между сокетами(тройное
рукопожатие у TCP).
После заполнения очереди система будет отвергать дополнительные запросы на соединение. 
Возвращает ошибку в случаях: сокет не привзан к адрессу, аргумент сокета не является допустимым файловым дескриптором, 
протокол не поддерживает прослушивание сокета, сокет был закрыт

4) Объяснить, как работает accept
Когда сервер получает от клиента запрос на соединение, он должен создать новый сокет для работы с новым 
соединением. Первый же сокет используется только для установки соединения. Дополнительный сокет создается при 
помощи вызова accept, принимающего очередное соединение. 
Если входящих сединений нет, то accept блокируется
Системному вызову accept первый параметром передается дескриптор сокета(слушающего, иначе ошибка). 
Второй параметр заполняется информацией о клиенте.
Возвращает дескриптор сокета, соединенного с клиентом, вызвавшим функцию connect. 
В случае ошибки возвращает -1. Возвращает ошибку, если:
Передали недопустимый файловый дескриптор, функция accept была прервана сигналом, который был перехвачен до 
установления соединения, достигнуто максимальное количество файловых дескрипторов в системе, тип сокета не 
поддерживает прием соединений.