Более однообразные регистры r0,r1, ...
sp - stack pointer = r13
load-store - архитектура
sub     sp, sp, #12    -  sp = sp - 12
str - store (запись) сохранение   	из регистра в память
ldr - чтение   загрузка			из памяти в регистр

pop  {r3,pc} - достает из стека эти два числа и записывает на регистры r3 и pc
Если что-то пишется в pc, то управление переходит к этой команде
str    r1, [r7] - чтение по адресу r7 и запись в r1

ldr    r7, [sp], #4   - записываем в r7 то, что по адресу sp и сдвигаем sp (аналог pop)
r0, r1 для передачи параметров в функцию, если регистров не хватает, то используется стекы

команды, начинающиеся на b - команды перехода(branch)

bl - link register

bx - команда безусловного перехода(аналог jump)

lr(r14) - link-register(место выхода для функции)
во время вызова функции адрес возврата помещается в lr(хранится на регистре)
в конце программы достаем адресс возврата в programm counter(pc) - адрес следующей команды для исполнения

ВЕЩЕСТВЕННАЯ АРИФМЕТИКА:
Появилась путем добавления специальных регистров и команд

vstr.64 d0, [r7, #8] - записать в d0 64 битное значение

vmrs - копирование флагов


-O1
Условные команды:
movlt - выполняется только при выполнении некоторого условия

lt lt
movlt r0,r1

addgt - условное сложение(сложить, если больше чем)



Параметры могут быть переданы стеку этапа выполнения или в регистрах
Результаты возвращаются в регистрах или в памяти
bl     	R14 := R15, R15 := address
	lr = pc, pc = adress

pc(используется для хранения адресов выполняющихся команд)
в lr помещается адрес команды, следующей за BL
register that stores the return address

0011 1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 -представление 1 в вещественной рафиметике
16368 = 0011 1111 1111 0000






Оптимизации:
-O1
Нет сохранения кадра стека
Cначала сделает первую проверку цикла, а только потом заведет локальные переменные
is_digit - не завел локальные переменные
Сильно меньше обращений в память
Используем большее кол-во регистров для удобства
Представляем константу по-другому
В exhibitor вообще не обращаемся в память
В foo нет обращения по адресу


-O2
uxtb    r3, r3 - нет этого
выкинули foo
работаем с входными сразу, не пересохраняем
exhibitor заинлайнился в main
-O3
-Os
.L20:
   .word   .LC0
   .word   .LC1
загрузка строки на регистр
inline выкинули

-Og
не изменяется позиция выделения локальных данных на стеке и проверок
foo не удалится
вызов функций с параметром(тип указан)
-Ofast